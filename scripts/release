#!/usr/bin/env bash

GITHOOKS_VERSION="v0.0.1-rc.0";
# https://github.com/gkide/githooks

# Semantic Version
# https://semver.org/
# Software Release Life Cycle
# https://en.wikipedia.org/wiki/Software_release_life_cycle
#
################################################################
#                       +----------------MUI--------------+    #
#  +-ADT-+              |  +--FIX--+                      |    #
#  |     |              |  |       |                      |    #
#  v     |              v  v       |                      |    #
# pre-* ===> alpha ===> beta ===> rc ===> [release] ===> eol   #
#  ^         |  ^       |  ^       ^          |                #
#  |         |  |       | MUI     FIX         |                #
#  +---MUI---+  +--MUI--+  |       |          |                #
#                          +-------+----------+                #
#                                                              #
# - ADT: Analysis, Design, Testing, ...                        #
# - MUI: Modify User Interfacce, feature changing, fix, ...    #
# - FIX: Bug fix, performance improvement, compatibility, ...  #
################################################################
#
# - pre-*
#   Refers to all activities performed before formal testing, like:
#   requirements analysis, software design, and related inter-testing
#
# - alpha
#   The first phase to begin software testing, normally using of
#   white-box, black-box or gray-box testing techniques, and may
#   not contain all of the features that the final version has.
#   It usually ends with features freeze, indicating that no more
#   features will be added to the software, known as feature complete.
#
# - beta
#   The second phase just following alpha, generally begins when the
#   software is feature complete but likely to contain a number of known
#   or unknown bugs, may have speed or performance issues, crashes or data
#   loss. The beta stage is focus on usability, for reducing impacts to the
#   end-users. The beta version is normally formally first release to user.
#
# - rc
#   The release candidate (RC), is the third phase of software development,
#   with potential to be the final version, which is ready to release unless
#   significant bugs emerge. In this stage, features are complete and stable,
#   tested through one or more beta cycles, no entirely new features will be
#   added. There can still have bug fix, change the documentation and testings.
#
# - eol
#   No longer supported, the release reached the end-of-life.

# Exit the script if any statement returns a non-true return value
set -e
# Show error if used undefined variable
set -u
# Pipe fail if any one of the pipe command failed
set -o pipefail

_sed=$([ "$(uname)" = "Darwin" ] && echo "sed -E" || echo "sed -r");

####################################
# Change working directory to repo #
####################################
REPO_DIR=$(git rev-parse --show-toplevel)
cd "${REPO_DIR}"

################################################################################
# Local configurations

# If the tweak need quotes
VS_TWEAK_QUOTES=""; # no quotes
#VS_TWEAK_QUOTES="S"; # signal quotes
#VS_TWEAK_QUOTES="D"; # double quotes

##########################
# Release Version Search #
##########################
# Version should consist of MAJOR/MINOR/PATCH/TWEAK
# - The MAJOR, MINOR, PATCH must consit of numbers of [0-9]
# - TWEAK is pre-release part, consist of [a-z0-9.-]
# Each line must has one, like the following
#    MY_VERSION_MAJOR
#    MY_VERSION_MINOR
#    MY_VERSION_PATCH
#    MY_VERSION_TWEAK
###########################
# Example of C/C++ header #
###########################
#define MY_VERSION_MAJOR 1     # Can not ignore, must be 0 ~ 9
#define MY_VERSION_MINOR 2     # Can not ignore, must be 0 ~ 9
#define MY_VERSION_PATCH 3     # Can not ignore, must be 0 ~ 9
#define MY_VERSION_TWEAK "pre" # Can be ignored, consist of [a-z0-9.-]
#
# Version search file, full path
if false; then
VS_VFILE="${REPO_DIR}/version.h";
VS_MAJOR="#define MY_VERSION_MAJOR";
VS_MINOR="#define MY_VERSION_MINOR";
VS_PATCH="#define MY_VERSION_PATCH";
VS_TWEAK="#define MY_VERSION_TWEAK";
fi
#
#############################
# Example of CMakeLists.txt #
#############################
#set(MY_VERSION_MAJOR 0)       # Can not ignore, must be 0 ~ 9
#set(MY_VERSION_MINOR 0)       # Can not ignore, must be 0 ~ 9
#set(MY_VERSION_PATCH 6)       # Can not ignore, must be 0 ~ 9
#set(MY_VERSION_TWEAK pre)     # Can be ignored, consist of [a-z0-9.-]
#
# Version search file, full path
if false; then
VS_VFILE="${REPO_DIR}/CMakeLists.txt";
VS_MAJOR="set(MY_VERSION_MAJOR";
VS_MINOR="set(MY_VERSION_MINOR";
VS_PATCH="set(MY_VERSION_PATCH";
VS_TWEAK="set(MY_VERSION_TWEAK";
fi
#
#########################
# Example of Other Type #
#########################
# Version search file, must be file in repo
if true; then
VS_VFILE="${REPO_DIR}/.version";
VS_MAJOR="MY_VERSION_MAJOR"; # Can not ignore, must be 0 ~ 9
VS_MINOR="MY_VERSION_MINOR"; # Can not ignore, must be 0 ~ 9
VS_PATCH="MY_VERSION_PATCH"; # Can not ignore, must be 0 ~ 9
VS_TWEAK="MY_VERSION_TWEAK"; # Can be ignored, consist of [a-z0-9.-]
fi
################################################################################

#####################################
# Import normal shell function-util #
# - IS_DEBUG_MODE=true;             #
# - IS_VERBOSE_MODE=true;           #
#####################################
source ${REPO_DIR}/scripts/utils.sh;
IS_DEBUG_MODE=false;

if [ ! -f ${VS_VFILE} ]; then
    errMsg "Do not exits $(keyMsg ${VS_VFILE})";
fi

# The version file should be one file of the repo subdirectory
fullPath=$(realpath ${VS_VFILE});
isRepoFile=${fullPath#${REPO_DIR}/};
if [ "${isRepoFile}" = "${fullPath}" ]; then
    errMsg "$(valMsg ${fullPath}) NOT in the repo
       $(keyMsg ${REPO_DIR})";
fi
VS_VFILE=${isRepoFile}; # Relative path of repo

infoMsg "Working repo $(valMsg ${REPO_DIR})";
infoMsg "-------------------------------------------------";
infoMsg "Just Enter with nothing will use default [value]";
infoMsg "-------------------------------------------------";

########################
# Check release branch #
########################
CURRENT_BRANCH=$(git status | head -n 1 | awk '{print $3}');
infoMsgL "Release branch $(valMsg ${CURRENT_BRANCH}) (y/n) [y]: ";
read -p "" usrInput;
[ -z "${usrInput}" ] && usrInput='Y'; # Just Enter is Yes

if ! isYes "${usrInput}"; then
    errMsg "Release stop.";
fi

###############################
# Software Release Life Cycle #
###############################
SRLC_REG="(([a-z]+)(-[a-z]+)*)(\.([0-9]+(\.[0-9]+)*))*";
SRLC_CAN="pre alpha beta rc eol"; # CAN: Candidates

SRLC_HELP="";
SRLC_FMTA="";
SRLC_FMTB="";
SRLC_FMTC="";
for item in ${SRLC_CAN}; do
    [ -n "${SRLC_HELP}" ] && SRLC_HELP="${SRLC_HELP}, ";
    SRLC_HELP="${SRLC_HELP}$(valMsg ${item})";

    [ -n "${SRLC_FMTA}" ] && SRLC_FMTA="${SRLC_FMTA}    ";
    [ -n "${SRLC_FMTB}" ] && SRLC_FMTB="${SRLC_FMTB}    ";
    [ -n "${SRLC_FMTC}" ] && SRLC_FMTC="${SRLC_FMTC}    ";
    if [ "${item}" != "eol" ]; then
        SRLC_FMTA="${SRLC_FMTA}${item}.123";
        SRLC_FMTB="${SRLC_FMTB}${item}-foo";
        SRLC_FMTC="${SRLC_FMTC}${item}-X.1";
    fi
done

# The TWEAK example usage
SRLC_HELP="${SRLC_HELP}
The TWEAK format as following, like:
    ${SRLC_FMTA}
    ${SRLC_FMTB}
    ${SRLC_FMTC}";

# Escape meta-char for RegExp
#   (   =>  \(
# space =>  \s+
_VS_MAJOR_=$(echo "${VS_MAJOR}" \
    | awk -F';' 'sub(/\(/,"\(",$1) sub(/ /,"\s+",$1) { print $1; }');
_VS_MINOR_=$(echo "${VS_MINOR}" \
    | awk -F';' 'sub(/\(/,"\(",$1) sub(/ /,"\s+",$1) { print $1; }');
_VS_PATCH_=$(echo "${VS_PATCH}" \
    | awk -F';' 'sub(/\(/,"\(",$1) sub(/ /,"\s+",$1) { print $1; }');
_VS_TWEAK_=$(echo "${VS_TWEAK}" \
    | awk -F';' 'sub(/\(/,"\(",$1) sub(/ /,"\s+",$1) { print $1; }');

# Version RegExp Pattern
REGEXP_MAJOR="^(${_VS_MAJOR_})\s+\\\"*'*([0-9]+)'*\\\"*\s*(.*)$";
REGEXP_MINOR="^(${_VS_MINOR_})\s+\\\"*'*([0-9]+)'*\\\"*\s*(.*)$";
REGEXP_PATCH="^(${_VS_PATCH_})\s+\\\"*'*([0-9]+)'*\\\"*\s*(.*)$";
REGEXP_TWEAK="^(${_VS_TWEAK_})\s*\\\"*'*([0-9a-z\.-]+)*'*\\\"*\s*(.*)$";
debugMsg "$(keyMsg RegExp Major): [$(valMsg ${REGEXP_MAJOR})]";
debugMsg "$(keyMsg RegExp Minor): [$(valMsg ${REGEXP_MINOR})]";
debugMsg "$(keyMsg RegExp Patch): [$(valMsg ${REGEXP_PATCH})]";
debugMsg "$(keyMsg RegExp Tweak): [$(valMsg ${REGEXP_TWEAK})]";

# Get old semver
VERSION_MAJOR=$(grep "${VS_MAJOR}" ${VS_VFILE} \
    | ${_sed} "s/${REGEXP_MAJOR}/\2/");
VERSION_MINOR=$(grep "${VS_MINOR}" ${VS_VFILE} \
    | ${_sed} "s/${REGEXP_MINOR}/\2/");
VERSION_PATCH=$(grep "${VS_PATCH}" ${VS_VFILE} \
    | ${_sed} "s/${REGEXP_PATCH}/\2/");
VERSION_TWEAK=$(grep "${VS_TWEAK}" ${VS_VFILE} \
    | ${_sed} "s/${REGEXP_TWEAK}/\2/");

if [ -z "${VERSION_MAJOR}" -o -z "{$VERSION_MINOR}" -o -z "${VERSION_PATCH}" ]; then
    errMsg "Get semantic version from $(keyMsg ${VS_VFILE}) failed";
fi

# Save the previous version
PREV_MAJOR=${VERSION_MAJOR}
PREV_MINOR=${VERSION_MINOR}
PREV_PATCH=${VERSION_PATCH}
PREV_TWEAK=${VERSION_TWEAK}

_major_="$(valMsg ${VERSION_MAJOR})";
_minor_="$(valMsg ${VERSION_MINOR})";
_patch_="$(valMsg ${VERSION_PATCH})";
_tweak_="$(valMsg ${VERSION_TWEAK})";
infoMsg "-------------------------------------------------";
infoMsg "Current semantic version
Major(${_major_})  Minor(${_minor_})  Patch(${_patch_})  Tweak(${_tweak_})";

PREV_TWEAK_TXT="";
PREV_TWEAK_NUM="";
[ -n "${VERSION_TWEAK}" ] && {
    PREV_TWEAK_TXT=$(echo "${VERSION_TWEAK}" | ${_sed} "s/^${SRLC_REG}$/\1/");
    PREV_TWEAK_NUM=$(echo "${VERSION_TWEAK}" | ${_sed} "s/^${SRLC_REG}$/\5/");
    IS_TXT=$(echo "${PREV_TWEAK_TXT}" | ${_sed} -n "/^[a-z]+(-[a-z]+)*$/p");
    IS_NUM=$(echo "${PREV_TWEAK_NUM}" | ${_sed} -n "/^[0-9]+(\.[0-9]+)*$/p");
    if [ -z "${IS_TXT}" -a -z "${IS_NUM}" ]; then
        errMsg "$(keyMsg ${VS_VFILE}) tweak shoule be: ${SRLC_HELP}";
    fi
    [ -z "${IS_TXT}" ] && PREV_TWEAK_TXT="";
    [ -z "${IS_NUM}" ] && PREV_TWEAK_NUM="";
    debugMsg "$(keyMsg Tweak old text): [$(valMsg ${PREV_TWEAK_TXT})]";
    debugMsg "$(keyMsg Tweak old nums): [$(valMsg ${PREV_TWEAK_NUM})]";
}

##############################################
# Update CHANGELOG.md & get next auto semver #
# SEMVER_TAG is like '1.2.3' or '1.2.3-1'    #
##############################################
CHANGELOG="CHANGELOG.md";
if [ ! -f "${CHANGELOG}" ]; then
    infoMsgL "Changelog to update (File) [$(valMsg ${CHANGELOG})]: ";
    read -p "" usrInput;
    [ -n "${usrInput}" ] && CHANGELOG="${usrInput}";

    fullPath=$(realpath -m ${CHANGELOG});
    isRepoFile=${fullPath#${REPO_DIR}/};
    if [ "${isRepoFile}" = "${fullPath}" ]; then
        errMsg "$(valMsg ${fullPath}) NOT in the repo
       $(keyMsg ${REPO_DIR})";
    fi
    CHANGELOG=${isRepoFile}; # Relative path of repo

    if [ ! -f "${CHANGELOG}" ]; then
        pathName=$(dirname ${CHANGELOG});
        [ ! -e "${pathName}" ] && mkdir -p ${pathName};
        touch "${CHANGELOG}";
    fi
fi

SEMVER_TAG=$(standard-release -x -c ${CHANGELOG} 2>/dev/null | head -n 1 \
    | awk -F':' 'gsub(/[ ]/,"",$2) { print $2; }');
[ -n "${SEMVER_TAG}" ] \
    || errMsg "Get auto semver failed, try install npm $(keyMsg standard-release)";

# Split auto semver into two parts
SEMVER_VAL=$(echo "${SEMVER_TAG}" \
    | awk 'sub(/v/,"",$1) sub(/-/,";",$1) { print $1; }');

AUTO_MMP=$(echo "${SEMVER_VAL}" | awk -F ';' '{ print $1; }');
debugMsg "$(keyMsg Auto major.minor.patch): [$(valMsg ${AUTO_MMP})]";
AUTO_MAJOR=$(echo "${AUTO_MMP}" | awk -F '.' '{ print $1; }');
AUTO_MINOR=$(echo "${AUTO_MMP}" | awk -F '.' '{ print $2; }');
AUTO_PATCH=$(echo "${AUTO_MMP}" | awk -F '.' '{ print $3; }');

AUTO_TWEAK_TXT="";
AUTO_TWEAK_NUM="";
AUTO_PREREL=$(echo "${SEMVER_VAL}" | awk -F ';' '{ print $2; }');
debugMsg "$(keyMsg Auto pre-release): [$(valMsg ${AUTO_PREREL})]";
if [ -n "${AUTO_PREREL}" ]; then
    AUTO_TWEAK_TXT=$(echo "${AUTO_PREREL}" | ${_sed} "s/^${SRLC_REG}$/\1/");
    AUTO_TWEAK_NUM=$(echo "${AUTO_PREREL}" | ${_sed} "s/^${SRLC_REG}$/\5/");
    IS_TXT=$(echo "${AUTO_TWEAK_TXT}" | ${_sed} -n "/^[a-z]+(-[a-z]+)*$/p");
    IS_NUM=$(echo "${AUTO_TWEAK_NUM}" | ${_sed} -n "/^[0-9]+(\.[0-9]+)*$/p");
    if [ -z "${IS_TXT}" -a -z "${IS_NUM}" ]; then
            errMsg "Auto git tag $(keyMsg pre-release) should be: ${SRLC_HELP}";
    fi
    [ -z "${IS_TXT}" ] && AUTO_TWEAK_TXT="";
    [ -z "${IS_NUM}" ] && AUTO_TWEAK_NUM="";
    debugMsg "$(keyMsg Auto tweak text): [$(valMsg ${AUTO_TWEAK_TXT})]";
    debugMsg "$(keyMsg Auto tweak nums): [$(valMsg ${AUTO_TWEAK_NUM})]";
fi

_major_="$(valMsg ${AUTO_MAJOR})";
[ "${PREV_MAJOR}" != "${AUTO_MAJOR}" ] \
    && _major_="$(msgRed ${AUTO_MAJOR})";

_minor_="$(valMsg ${AUTO_MINOR})";
[ "${PREV_MINOR}" != "${AUTO_MINOR}" ] \
    && _minor_="$(msgRed ${AUTO_MINOR})";

_patch_="$(valMsg ${AUTO_PATCH})";
[ "${PREV_PATCH}" != "${AUTO_PATCH}" ] \
    && _patch_="$(msgRed ${AUTO_PATCH})";

_tweak_="$(valMsg ${AUTO_PREREL})";
if [ "${PREV_TWEAK}" != "${AUTO_PREREL}" ]; then
    _tweak_=""; # clean it
    if [ -n "${AUTO_TWEAK_TXT}" ]; then
        _tweak_="$(valMsg ${AUTO_TWEAK_TXT})";
        [ "${PREV_TWEAK_TXT}" != "${AUTO_TWEAK_TXT}" ] \
            && _tweak_="$(msgRed ${AUTO_TWEAK_TXT})";
    fi

    if [ -n "${AUTO_TWEAK_NUM}" ]; then
        if [ "${PREV_TWEAK_NUM}" != "${AUTO_TWEAK_NUM}" ]; then
            _tweak_="${_tweak_}$(msgRed .${AUTO_TWEAK_NUM})";
        else
            _tweak_="${_tweak_}$(valMsg .${AUTO_TWEAK_NUM})";
        fi
    fi
fi

infoMsg "Next auto semantic version
Major(${_major_})  Minor(${_minor_})  Patch(${_patch_})  Tweak(${_tweak_})";

AUTO_BUMP_SEMVER=false;
infoMsg "-------------------------------------------------";
infoMsgL "Use auto semantic version (y/n) [y]: ";
read -p "" usrInput;
[ -z "${usrInput}" ] && usrInput='Y'; # Just Enter is Yes
if isYes "${usrInput}"; then
    AUTO_BUMP_SEMVER=true;
    VERSION_MAJOR=${AUTO_MAJOR};
    VERSION_MINOR=${AUTO_MINOR};
    VERSION_PATCH=${AUTO_PATCH};

    VERSION_TWEAK=${AUTO_PREREL}; # may be just numbers, no ascii text
    IS_NUM=$(echo "${VERSION_TWEAK}" | ${_sed} -n "/^[0-9]+(\.[0-9]+)*$/p");
    [ -n "${IS_NUM}" ] && VERSION_TWEAK="rc.${VERSION_TWEAK}";
fi

# The final major
infoMsgL "Major (New Major) [$(valMsg ${VERSION_MAJOR})]: ";
read -p "" usrInput;
case "${usrInput}" in
"")
    # Just Enter is empty, just use it, no touching
    ;;
*)
    IS_NUM=$(echo "${usrInput}" | ${_sed} -n "/^[0-9]+$/p");
    [ -z "${IS_NUM}" ] && errMsg "$(keyMsg Major) must be numbers of 0-9.";
    VERSION_MAJOR="${usrInput}";
    AUTO_BUMP_SEMVER=true;
    ;;
esac

# The final minor
infoMsgL "Minor (New Minor) [$(valMsg ${VERSION_MINOR})]: ";
read -p "" usrInput;
case "${usrInput}" in
"")
    # Just Enter is empty, just use it, no touching
    ;;
*)
    IS_NUM=$(echo "${usrInput}" | ${_sed} -n "/^[0-9]+$/p");
    [ -z "${IS_NUM}" ] && errMsg "$(keyMsg Minor) must be numbers of 0-9.";
    VERSION_MINOR="${usrInput}";
    AUTO_BUMP_SEMVER=true;
    ;;
esac

# The final patch
infoMsgL "Patch (New Patch) [$(valMsg ${VERSION_PATCH})]: ";
read -p "" usrInput;
case "${usrInput}" in
"")
    # Just Enter is empty, just use it, no touching
    ;;
*)
    IS_NUM=$(echo "${usrInput}" | ${_sed} -n "/^[0-9]+$/p");
    [ -z "${IS_NUM}" ] && errMsg "$(keyMsg Patch) must be numbers of 0-9.";
    VERSION_PATCH="${usrInput}";
    AUTO_BUMP_SEMVER=true;
    ;;
esac

# The final tweak
infoMsgL "Tweak (New Tweak or $(keyMsg SKIP)) [$(valMsg ${VERSION_TWEAK})]: ";
read -p "" usrInput;
case "${usrInput}" in
"")
    # Just Enter is empty, just use it, no touching
    ;;
"SKIP")
    # Tweak skip, empty the value
    if [ -n "${VERSION_TWEAK}" ]; then
        # Not auto bump, clean ${VS_VFILE} tweak part only
        VERSION_TWEAK="";
        AUTO_BUMP_SEMVER=true;
    fi
    ;;
*)
    VERSION_TWEAK="${usrInput}";
    AUTO_BUMP_SEMVER=true; # new tweak value
    ;;
esac

VERSION_TWEAK_TXT="";
VERSION_TWEAK_NUM="";

# Checking tweak if not empty
[ -n "${VERSION_TWEAK}" ] && {
    tweakSRLC=$(echo "${VERSION_TWEAK}" | ${_sed} "s/^${SRLC_REG}$/\2/");
    debugMsg "$(keyMsg Final tweak SRLC): [$(valMsg ${tweakSRLC})]";

    IS_OK=false;
    tweakInfo="$(valMsg ${VERSION_TWEAK})";
    for item in ${SRLC_CAN}; do
        [ "${tweakSRLC}" = "${item}" ] && IS_OK=true && break;
    done

    if ! ${IS_OK}; then
        errMsg "$(keyMsg TWEAK)(${tweakInfo}) must be one of: ${SRLC_HELP}";
    fi

    tweak_TXT=$(echo "${VERSION_TWEAK}" | ${_sed} "s/^${SRLC_REG}$/\1/");
    tweak_NUM=$(echo "${VERSION_TWEAK}" | ${_sed} "s/^${SRLC_REG}$/\5/");

    # Checking again because the value may be overwrite from cmd-line
    IS_TXT=$(echo "${tweak_TXT}" | ${_sed} -n "/^[a-z]+(-[a-z]+)*$/p");
    IS_NUM=$(echo "${tweak_NUM}" | ${_sed} -n "/^[0-9]+(\.[0-9]+)*$/p");
    if [ -z "${IS_TXT}" -a -z "${IS_NUM}" ]; then
        errMsg "$(keyMsg TWEAK)(${tweakInfo}) format should be: ${SRLC_HELP}";
    fi

    [ -z "${IS_TXT}" ] && tweak_TXT="";
    [ -z "${IS_NUM}" ] && tweak_NUM="";

    VERSION_TWEAK_TXT="${tweak_TXT}";
    VERSION_TWEAK_NUM="${tweak_NUM}";
    debugMsg "$(keyMsg Final tweak text): [$(valMsg ${tweak_TXT})]";
    debugMsg "$(keyMsg Final tweak nums): [$(valMsg ${tweak_NUM})]";
}

if [ -z "${VERSION_TWEAK}" ]; then
    RELEASE_TAG="v${VERSION_MAJOR}.${VERSION_MINOR}.${VERSION_PATCH}"
else
    RELEASE_TAG="v${VERSION_MAJOR}.${VERSION_MINOR}.${VERSION_PATCH}-${VERSION_TWEAK}"
fi

{ [ -z "${VERSION_MAJOR}" ] || [ -z "{$VERSION_MINOR}" ] || [ -z "${VERSION_PATCH}" ]; } \
    && errMsg "Release semver($(valMsg ${RELEASE_TAG})) error";

# Check if RELEASE_TAG is valid semver
if ! $(standard-release -x --is-semver "${RELEASE_TAG}"); then
    errMsg "Invalid release semver($(valMsg ${RELEASE_TAG}))";
fi

for tag in $(git tag --list); do
    [ "${tag}" = "${RELEASE_TAG}" ] \
        && errMsg "The semver tag $(valMsg ${tag}) already exists";
done

# Sync CHANGELOG.md release tag to the one really used
${_sed} -i.bk "s/${SEMVER_TAG}/${RELEASE_TAG}/g" ${CHANGELOG}
rm ${CHANGELOG}.bk;

infoMsg "-------------------------------------------------";
_major_="$(valMsg ${VERSION_MAJOR})";
[ "${PREV_MAJOR}" != "${VERSION_MAJOR}" ] \
    && _major_="$(msgRed ${VERSION_MAJOR})";

_minor_="$(valMsg ${VERSION_MINOR})";
[ "${PREV_MINOR}" != "${VERSION_MINOR}" ] \
    && _minor_="$(msgRed ${VERSION_MINOR})";

_patch_="$(valMsg ${VERSION_PATCH})";
[ "${PREV_PATCH}" != "${VERSION_PATCH}" ] \
    && _patch_="$(msgRed ${VERSION_PATCH})";

_tweak_="$(valMsg ${VERSION_TWEAK})";
if [ "${PREV_TWEAK}" != "${VERSION_TWEAK}" ]; then
    _tweak_=""; # clean it
    if [ -n "${VERSION_TWEAK_TXT}" ]; then
        _tweak_="$(valMsg ${VERSION_TWEAK_TXT})";
        [ "${PREV_TWEAK_TXT}" != "${VERSION_TWEAK_TXT}" ] \
            && _tweak_="$(msgRed ${VERSION_TWEAK_TXT})";
    fi

    if [ -n "${VERSION_TWEAK_NUM}" ]; then
        if [ "${PREV_TWEAK_NUM}" != "${VERSION_TWEAK_NUM}" ]; then
            _tweak_="${_tweak_}$(msgRed .${VERSION_TWEAK_NUM})";
        else
            _tweak_="${_tweak_}$(valMsg .${VERSION_TWEAK_NUM})";
        fi
    fi
fi

# Make the output pretty look
maxStrLen=$(maxNum ${#PREV_MAJOR} ${#PREV_MINOR} ${#PREV_PATCH} ${#PREV_TWEAK});

indentA="";
strLen=${#PREV_MAJOR};
while [ ${strLen} -le ${maxStrLen} ]; do
  let strLen++;
  indentA="${indentA} ";
done

indentB="";
strLen=${#PREV_MINOR};
while [ ${strLen} -le ${maxStrLen} ]; do
  let strLen++;
  indentB="${indentB} ";
done

indentC="";
strLen=${#PREV_PATCH};
while [ ${strLen} -le ${maxStrLen} ]; do
  let strLen++;
  indentC="${indentC} ";
done

indentD="";
strLen=${#PREV_TWEAK};
while [ ${strLen} -le ${maxStrLen} ]; do
  let strLen=strLen+1;
  indentD="${indentD} ";
done

#debugMsg "$(keyMsg Max length): [$(valMsg ${maxStrLen})]";
#debugMsg "$(keyMsg Major indent): [${indentA}]";
#debugMsg "$(keyMsg Minor indent): [${indentB}]";
#debugMsg "$(keyMsg Patch indent): [${indentC}]";
#debugMsg "$(keyMsg Tweak indent): [${indentD}]";

# The previous latest tag
LATEST_TAG=$(git describe --abbrev=0 --tags 2>/dev/null || echo "");
[ -z "${LATEST_TAG}" ] && LATEST_TAG="init commit";

infoMsg "Recently tag : $(keyMsg ${LATEST_TAG})";
infoMsg "Release tag  : $(valMsg ${RELEASE_TAG})";
infoMsg "Release major: $(valMsg ${PREV_MAJOR})${indentA}=> ${_major_}";
infoMsg "Release minor: $(valMsg ${PREV_MINOR})${indentB}=> ${_minor_}";
infoMsg "Release patch: $(valMsg ${PREV_PATCH})${indentC}=> ${_patch_}";
infoMsg "Release tweak: $(valMsg ${PREV_TWEAK})${indentD}=> ${_tweak_}";

if ${AUTO_BUMP_SEMVER}; then
    # Update Version
    ${_sed} -i.bk "s/${REGEXP_MAJOR}/\1 ${VERSION_MAJOR}\3/" ${VS_VFILE};
    ${_sed} -i.bk "s/${REGEXP_MINOR}/\1 ${VERSION_MINOR}\3/" ${VS_VFILE};
    ${_sed} -i.bk "s/${REGEXP_PATCH}/\1 ${VERSION_PATCH}\3/" ${VS_VFILE};

    case "${VS_TWEAK_QUOTES}" in
    "S")
        if [ -z "${VERSION_TWEAK}" ]; then
            ${_sed} -i.bk "s/${REGEXP_TWEAK}/\1''\3/" ${VS_VFILE}; # empty tweak
        else
            ${_sed} -i.bk "s/${REGEXP_TWEAK}/\1 '${VERSION_TWEAK}'\3/" ${VS_VFILE};
        fi
        ;;
    "D")
        if [ -z "${VERSION_TWEAK}" ]; then
            ${_sed} -i.bk "s/${REGEXP_TWEAK}/\1\"\"\3/" ${VS_VFILE}; # empty tweak
        else
            ${_sed} -i.bk "s/${REGEXP_TWEAK}/\1 \"${VERSION_TWEAK}\"\3/" ${VS_VFILE};
        fi
        ;;
    *)
        if [ -z "${VERSION_TWEAK}" ]; then
            ${_sed} -i.bk "s/${REGEXP_TWEAK}/\1\3/" ${VS_VFILE}; # empty tweak
        else
            ${_sed} -i.bk "s/${REGEXP_TWEAK}/\1 ${VERSION_TWEAK}\3/" ${VS_VFILE};
        fi
    esac

    rm ${VS_VFILE}.bk;
fi

PKG_VERSION=$(echo "${RELEASE_TAG}" | awk 'gsub(/v/,"",$1) { print $1; }');
${_sed} -i.bk "s/^(\s+\"version\":\s+\")[^\"]+(\",$)/\1${PKG_VERSION}\2/" package.json;
rm package.json.bk;

infoMsg "-------------------------------------------------";
infoMsgL "Show $(valMsg ${CHANGELOG}) diff (y/n) [n]: ";
read -p "" usrInput;
if isYes "${usrInput}"; then
    git diff ${CHANGELOG};
fi

infoMsg "-------------------------------------------------";
infoMsgL "Show $(valMsg ${VS_VFILE}) diff (y/n) [n]: ";
read -p "" usrInput;
if isYes "${usrInput}"; then
    git diff ${VS_VFILE};
    git diff package.json;
fi

# Git Commit & Tag
TAG_HDR="chore(auto): tag ${RELEASE_TAG}";
CMT_HDR="chore(auto): release ${RELEASE_TAG}";
MSG_BDY="

- Detail changes see ${CHANGELOG}
- Building changelog since ${LATEST_TAG}";

TAG_MSG="${TAG_HDR}${MSG_BDY}";
COMMIT_MSG="${CMT_HDR}${MSG_BDY}";

infoMsg "-------------------------------------------------";
infoMsg "The message for signed-off commit";
printf "$(msgGreen "${COMMIT_MSG}")\n";

infoMsg "The message for signed annotated tag";
printf "$(msgGreen "${TAG_MSG}")\n";

# Really want to do this
infoMsg "-------------------------------------------------";
infoMsgL "Confirm git commit & tag (y/n) [n]: ";
read -p "" usrInput;
if isNo "${usrInput}"; then
    yesMsg="$(keyMsg y), $(keyMsg yes), $(keyMsg Y)";
    yesMsg="${yesMsg}, $(keyMsg Yes) or $(keyMsg YES)";
    errMsg "Release stop, confirm with ${yesMsg}";
fi

if isYes "${usrInput}"; then
    git add package.json;
    git add ${VS_VFILE};  # Update version
    git add ${CHANGELOG}; # Update changelog

    # Do release commit
    git commit --signoff -m "${COMMIT_MSG}";
    # Do release tag
    git tag --sign -a "${RELEASE_TAG}" -m "${TAG_MSG}";
fi

infoMsg "################";
infoMsg "# Release Done #";
infoMsg "################";
